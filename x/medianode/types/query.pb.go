// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: OmniFlix/medianode/v1beta1/query.proto

package types

import (
	context "context"
	fmt "fmt"
	query "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryMediaNodeRequest is the request type for querying a specific media node
type QueryMediaNodeRequest struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *QueryMediaNodeRequest) Reset()         { *m = QueryMediaNodeRequest{} }
func (m *QueryMediaNodeRequest) String() string { return proto.CompactTextString(m) }
func (*QueryMediaNodeRequest) ProtoMessage()    {}
func (*QueryMediaNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d56f7469bdc9159, []int{0}
}
func (m *QueryMediaNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMediaNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMediaNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMediaNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMediaNodeRequest.Merge(m, src)
}
func (m *QueryMediaNodeRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryMediaNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMediaNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMediaNodeRequest proto.InternalMessageInfo

func (m *QueryMediaNodeRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// QueryMediaNodeResponse is the response type for querying a specific media node
type QueryMediaNodeResponse struct {
	MediaNode MediaNode `protobuf:"bytes,1,opt,name=media_node,json=mediaNode,proto3" json:"media_node"`
}

func (m *QueryMediaNodeResponse) Reset()         { *m = QueryMediaNodeResponse{} }
func (m *QueryMediaNodeResponse) String() string { return proto.CompactTextString(m) }
func (*QueryMediaNodeResponse) ProtoMessage()    {}
func (*QueryMediaNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d56f7469bdc9159, []int{1}
}
func (m *QueryMediaNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMediaNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMediaNodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMediaNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMediaNodeResponse.Merge(m, src)
}
func (m *QueryMediaNodeResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryMediaNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMediaNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMediaNodeResponse proto.InternalMessageInfo

func (m *QueryMediaNodeResponse) GetMediaNode() MediaNode {
	if m != nil {
		return m.MediaNode
	}
	return MediaNode{}
}

// QueryMediaNodesRequest is the request type for querying all media nodes
type QueryMediaNodesRequest struct {
	Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryMediaNodesRequest) Reset()         { *m = QueryMediaNodesRequest{} }
func (m *QueryMediaNodesRequest) String() string { return proto.CompactTextString(m) }
func (*QueryMediaNodesRequest) ProtoMessage()    {}
func (*QueryMediaNodesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d56f7469bdc9159, []int{2}
}
func (m *QueryMediaNodesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMediaNodesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMediaNodesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMediaNodesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMediaNodesRequest.Merge(m, src)
}
func (m *QueryMediaNodesRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryMediaNodesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMediaNodesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMediaNodesRequest proto.InternalMessageInfo

func (m *QueryMediaNodesRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryMediaNodesResponse is the response type for querying all media nodes
type QueryMediaNodesResponse struct {
	MediaNodes []MediaNode         `protobuf:"bytes,1,rep,name=media_nodes,json=mediaNodes,proto3" json:"media_nodes"`
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryMediaNodesResponse) Reset()         { *m = QueryMediaNodesResponse{} }
func (m *QueryMediaNodesResponse) String() string { return proto.CompactTextString(m) }
func (*QueryMediaNodesResponse) ProtoMessage()    {}
func (*QueryMediaNodesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d56f7469bdc9159, []int{3}
}
func (m *QueryMediaNodesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMediaNodesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMediaNodesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMediaNodesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMediaNodesResponse.Merge(m, src)
}
func (m *QueryMediaNodesResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryMediaNodesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMediaNodesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMediaNodesResponse proto.InternalMessageInfo

func (m *QueryMediaNodesResponse) GetMediaNodes() []MediaNode {
	if m != nil {
		return m.MediaNodes
	}
	return nil
}

func (m *QueryMediaNodesResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryMediaNodesByOwnerRequest is the request type for querying media nodes by owner
type QueryMediaNodesByOwnerRequest struct {
	Owner      string             `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryMediaNodesByOwnerRequest) Reset()         { *m = QueryMediaNodesByOwnerRequest{} }
func (m *QueryMediaNodesByOwnerRequest) String() string { return proto.CompactTextString(m) }
func (*QueryMediaNodesByOwnerRequest) ProtoMessage()    {}
func (*QueryMediaNodesByOwnerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d56f7469bdc9159, []int{4}
}
func (m *QueryMediaNodesByOwnerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMediaNodesByOwnerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMediaNodesByOwnerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMediaNodesByOwnerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMediaNodesByOwnerRequest.Merge(m, src)
}
func (m *QueryMediaNodesByOwnerRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryMediaNodesByOwnerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMediaNodesByOwnerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMediaNodesByOwnerRequest proto.InternalMessageInfo

func (m *QueryMediaNodesByOwnerRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *QueryMediaNodesByOwnerRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryMediaNodesByOwnerResponse is the response type for querying media nodes by owner
type QueryMediaNodesByOwnerResponse struct {
	MediaNodes []MediaNode         `protobuf:"bytes,1,rep,name=media_nodes,json=mediaNodes,proto3" json:"media_nodes"`
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryMediaNodesByOwnerResponse) Reset()         { *m = QueryMediaNodesByOwnerResponse{} }
func (m *QueryMediaNodesByOwnerResponse) String() string { return proto.CompactTextString(m) }
func (*QueryMediaNodesByOwnerResponse) ProtoMessage()    {}
func (*QueryMediaNodesByOwnerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d56f7469bdc9159, []int{5}
}
func (m *QueryMediaNodesByOwnerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMediaNodesByOwnerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMediaNodesByOwnerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMediaNodesByOwnerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMediaNodesByOwnerResponse.Merge(m, src)
}
func (m *QueryMediaNodesByOwnerResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryMediaNodesByOwnerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMediaNodesByOwnerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMediaNodesByOwnerResponse proto.InternalMessageInfo

func (m *QueryMediaNodesByOwnerResponse) GetMediaNodes() []MediaNode {
	if m != nil {
		return m.MediaNodes
	}
	return nil
}

func (m *QueryMediaNodesByOwnerResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryLeaseRequest is the request type for querying a specific lease
type QueryLeaseRequest struct {
	MediaNodeId uint64 `protobuf:"varint,1,opt,name=media_node_id,json=mediaNodeId,proto3" json:"media_node_id,omitempty"`
}

func (m *QueryLeaseRequest) Reset()         { *m = QueryLeaseRequest{} }
func (m *QueryLeaseRequest) String() string { return proto.CompactTextString(m) }
func (*QueryLeaseRequest) ProtoMessage()    {}
func (*QueryLeaseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d56f7469bdc9159, []int{6}
}
func (m *QueryLeaseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLeaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLeaseRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLeaseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLeaseRequest.Merge(m, src)
}
func (m *QueryLeaseRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryLeaseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLeaseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLeaseRequest proto.InternalMessageInfo

func (m *QueryLeaseRequest) GetMediaNodeId() uint64 {
	if m != nil {
		return m.MediaNodeId
	}
	return 0
}

// QueryLeaseResponse is the response type for querying a specific lease
type QueryLeaseResponse struct {
	Lease Lease `protobuf:"bytes,1,opt,name=lease,proto3" json:"lease"`
}

func (m *QueryLeaseResponse) Reset()         { *m = QueryLeaseResponse{} }
func (m *QueryLeaseResponse) String() string { return proto.CompactTextString(m) }
func (*QueryLeaseResponse) ProtoMessage()    {}
func (*QueryLeaseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d56f7469bdc9159, []int{7}
}
func (m *QueryLeaseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLeaseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLeaseResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLeaseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLeaseResponse.Merge(m, src)
}
func (m *QueryLeaseResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryLeaseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLeaseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLeaseResponse proto.InternalMessageInfo

func (m *QueryLeaseResponse) GetLease() Lease {
	if m != nil {
		return m.Lease
	}
	return Lease{}
}

// QueryLeasesByLesseeRequest is the request type for querying leases by lessee
type QueryLeasesByLesseeRequest struct {
	Lessee     string             `protobuf:"bytes,1,opt,name=lessee,proto3" json:"lessee,omitempty"`
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryLeasesByLesseeRequest) Reset()         { *m = QueryLeasesByLesseeRequest{} }
func (m *QueryLeasesByLesseeRequest) String() string { return proto.CompactTextString(m) }
func (*QueryLeasesByLesseeRequest) ProtoMessage()    {}
func (*QueryLeasesByLesseeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d56f7469bdc9159, []int{8}
}
func (m *QueryLeasesByLesseeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLeasesByLesseeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLeasesByLesseeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLeasesByLesseeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLeasesByLesseeRequest.Merge(m, src)
}
func (m *QueryLeasesByLesseeRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryLeasesByLesseeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLeasesByLesseeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLeasesByLesseeRequest proto.InternalMessageInfo

func (m *QueryLeasesByLesseeRequest) GetLessee() string {
	if m != nil {
		return m.Lessee
	}
	return ""
}

func (m *QueryLeasesByLesseeRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryLeasesByLesseeResponse is the response type for querying leases by lessee
type QueryLeasesByLesseeResponse struct {
	Leases     []Lease             `protobuf:"bytes,1,rep,name=leases,proto3" json:"leases"`
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryLeasesByLesseeResponse) Reset()         { *m = QueryLeasesByLesseeResponse{} }
func (m *QueryLeasesByLesseeResponse) String() string { return proto.CompactTextString(m) }
func (*QueryLeasesByLesseeResponse) ProtoMessage()    {}
func (*QueryLeasesByLesseeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d56f7469bdc9159, []int{9}
}
func (m *QueryLeasesByLesseeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLeasesByLesseeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLeasesByLesseeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLeasesByLesseeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLeasesByLesseeResponse.Merge(m, src)
}
func (m *QueryLeasesByLesseeResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryLeasesByLesseeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLeasesByLesseeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLeasesByLesseeResponse proto.InternalMessageInfo

func (m *QueryLeasesByLesseeResponse) GetLeases() []Lease {
	if m != nil {
		return m.Leases
	}
	return nil
}

func (m *QueryLeasesByLesseeResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAvailableNodesRequest is the request type for querying available nodes
type QueryAvailableNodesRequest struct {
	Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAvailableNodesRequest) Reset()         { *m = QueryAvailableNodesRequest{} }
func (m *QueryAvailableNodesRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAvailableNodesRequest) ProtoMessage()    {}
func (*QueryAvailableNodesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d56f7469bdc9159, []int{10}
}
func (m *QueryAvailableNodesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAvailableNodesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAvailableNodesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAvailableNodesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAvailableNodesRequest.Merge(m, src)
}
func (m *QueryAvailableNodesRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAvailableNodesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAvailableNodesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAvailableNodesRequest proto.InternalMessageInfo

func (m *QueryAvailableNodesRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAvailableNodesResponse is the response type for querying available nodes
type QueryAvailableNodesResponse struct {
	MediaNodes []MediaNode         `protobuf:"bytes,1,rep,name=media_nodes,json=mediaNodes,proto3" json:"media_nodes"`
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAvailableNodesResponse) Reset()         { *m = QueryAvailableNodesResponse{} }
func (m *QueryAvailableNodesResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAvailableNodesResponse) ProtoMessage()    {}
func (*QueryAvailableNodesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d56f7469bdc9159, []int{11}
}
func (m *QueryAvailableNodesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAvailableNodesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAvailableNodesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAvailableNodesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAvailableNodesResponse.Merge(m, src)
}
func (m *QueryAvailableNodesResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAvailableNodesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAvailableNodesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAvailableNodesResponse proto.InternalMessageInfo

func (m *QueryAvailableNodesResponse) GetMediaNodes() []MediaNode {
	if m != nil {
		return m.MediaNodes
	}
	return nil
}

func (m *QueryAvailableNodesResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func init() {
	proto.RegisterType((*QueryMediaNodeRequest)(nil), "OmniFlix.medianode.v1beta1.QueryMediaNodeRequest")
	proto.RegisterType((*QueryMediaNodeResponse)(nil), "OmniFlix.medianode.v1beta1.QueryMediaNodeResponse")
	proto.RegisterType((*QueryMediaNodesRequest)(nil), "OmniFlix.medianode.v1beta1.QueryMediaNodesRequest")
	proto.RegisterType((*QueryMediaNodesResponse)(nil), "OmniFlix.medianode.v1beta1.QueryMediaNodesResponse")
	proto.RegisterType((*QueryMediaNodesByOwnerRequest)(nil), "OmniFlix.medianode.v1beta1.QueryMediaNodesByOwnerRequest")
	proto.RegisterType((*QueryMediaNodesByOwnerResponse)(nil), "OmniFlix.medianode.v1beta1.QueryMediaNodesByOwnerResponse")
	proto.RegisterType((*QueryLeaseRequest)(nil), "OmniFlix.medianode.v1beta1.QueryLeaseRequest")
	proto.RegisterType((*QueryLeaseResponse)(nil), "OmniFlix.medianode.v1beta1.QueryLeaseResponse")
	proto.RegisterType((*QueryLeasesByLesseeRequest)(nil), "OmniFlix.medianode.v1beta1.QueryLeasesByLesseeRequest")
	proto.RegisterType((*QueryLeasesByLesseeResponse)(nil), "OmniFlix.medianode.v1beta1.QueryLeasesByLesseeResponse")
	proto.RegisterType((*QueryAvailableNodesRequest)(nil), "OmniFlix.medianode.v1beta1.QueryAvailableNodesRequest")
	proto.RegisterType((*QueryAvailableNodesResponse)(nil), "OmniFlix.medianode.v1beta1.QueryAvailableNodesResponse")
}

func init() {
	proto.RegisterFile("OmniFlix/medianode/v1beta1/query.proto", fileDescriptor_0d56f7469bdc9159)
}

var fileDescriptor_0d56f7469bdc9159 = []byte{
	// 735 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x96, 0xcf, 0x4f, 0x13, 0x41,
	0x14, 0xc7, 0x3b, 0x95, 0x12, 0x79, 0x44, 0x12, 0x26, 0x88, 0x64, 0xd5, 0x15, 0xd6, 0x08, 0xa8,
	0x61, 0x27, 0xa5, 0x06, 0x82, 0x89, 0x31, 0xf6, 0x80, 0xd1, 0x20, 0x68, 0xbd, 0x79, 0xc1, 0x29,
	0x3b, 0x2e, 0x93, 0xb4, 0x3b, 0x85, 0xd9, 0xa2, 0x4d, 0xed, 0xc5, 0xbf, 0xc0, 0xc4, 0x7f, 0x40,
	0xbd, 0x78, 0xf0, 0xe2, 0xc1, 0xe8, 0x1f, 0xe0, 0x85, 0x23, 0x89, 0x17, 0x4f, 0xc6, 0x80, 0x7f,
	0x88, 0xd9, 0xd9, 0xd9, 0xed, 0x0f, 0x4a, 0x7f, 0x10, 0x4c, 0x38, 0xb5, 0x33, 0xfb, 0xde, 0xfb,
	0x7e, 0xde, 0x9b, 0xe9, 0xb7, 0x0b, 0xd3, 0x6b, 0x45, 0x8f, 0x2f, 0x17, 0xf8, 0x2b, 0x52, 0x64,
	0x0e, 0xa7, 0x9e, 0x70, 0x18, 0xd9, 0x49, 0xe7, 0x99, 0x4f, 0xd3, 0x64, 0xab, 0xcc, 0xb6, 0x2b,
	0x76, 0x69, 0x5b, 0xf8, 0x02, 0x1b, 0x51, 0x9c, 0x1d, 0xc7, 0xd9, 0x3a, 0xce, 0x18, 0x73, 0x85,
	0x2b, 0x54, 0x18, 0x09, 0xbe, 0x85, 0x19, 0xc6, 0x25, 0x57, 0x08, 0xb7, 0xc0, 0x08, 0x2d, 0x71,
	0x42, 0x3d, 0x4f, 0xf8, 0xd4, 0xe7, 0xc2, 0x93, 0xfa, 0xe9, 0x8d, 0x0d, 0x21, 0x8b, 0x42, 0x92,
	0x3c, 0x95, 0x2c, 0x14, 0x8a, 0x65, 0x4b, 0xd4, 0xe5, 0x9e, 0x0a, 0x8e, 0x62, 0x3b, 0x30, 0xd6,
	0x69, 0x54, 0xac, 0x35, 0x03, 0xe7, 0x9f, 0x04, 0xd5, 0x1e, 0x05, 0xfb, 0xab, 0xc2, 0x61, 0x39,
	0xb6, 0x55, 0x66, 0xd2, 0xc7, 0x23, 0x90, 0xe4, 0xce, 0x04, 0x9a, 0x44, 0xb3, 0x03, 0xb9, 0x24,
	0x77, 0x2c, 0x07, 0xc6, 0x5b, 0x03, 0x65, 0x49, 0x78, 0x92, 0xe1, 0x87, 0x00, 0xaa, 0xea, 0x7a,
	0x50, 0x56, 0x65, 0x0c, 0xcf, 0x5f, 0xb3, 0x8f, 0xee, 0xdf, 0x8e, 0x4b, 0x64, 0x07, 0x76, 0x7f,
	0x5f, 0x49, 0xe4, 0x86, 0x8a, 0xd1, 0x86, 0xf5, 0xbc, 0x55, 0x45, 0x46, 0x3c, 0xcb, 0x00, 0xf5,
	0x46, 0xb5, 0xca, 0xb4, 0x1d, 0x4e, 0xc5, 0x0e, 0xa6, 0x62, 0x87, 0xe3, 0x8f, 0x44, 0x1e, 0x53,
	0x37, 0xea, 0x25, 0xd7, 0x90, 0x69, 0x7d, 0x41, 0x70, 0xe1, 0x90, 0x84, 0xee, 0x64, 0x05, 0x86,
	0xeb, 0x9d, 0xc8, 0x09, 0x34, 0x79, 0xa6, 0xdf, 0x56, 0x20, 0x6e, 0x45, 0xe2, 0xfb, 0x4d, 0xc4,
	0x49, 0x45, 0x3c, 0xd3, 0x95, 0x38, 0x44, 0x69, 0x42, 0xae, 0xc1, 0xe5, 0x16, 0xe2, 0x6c, 0x65,
	0xed, 0xa5, 0xc7, 0xb6, 0xa3, 0xd9, 0x8c, 0x41, 0x4a, 0x04, 0x6b, 0x35, 0x96, 0xa1, 0x5c, 0xb8,
	0x68, 0x99, 0x58, 0xf2, 0xd8, 0x13, 0xfb, 0x8e, 0xc0, 0x3c, 0x4a, 0xff, 0x74, 0x0f, 0x6e, 0x11,
	0x46, 0x15, 0xf8, 0x0a, 0xa3, 0x32, 0xbe, 0xd8, 0x16, 0x9c, 0xab, 0xb3, 0xae, 0xc7, 0x77, 0x7c,
	0x38, 0x06, 0x78, 0xe0, 0x58, 0x4f, 0x01, 0x37, 0x26, 0xea, 0x2e, 0xef, 0x40, 0xaa, 0x10, 0x6c,
	0xe8, 0xdb, 0x37, 0xd5, 0xa9, 0x3f, 0x95, 0xa9, 0x7b, 0x0b, 0xb3, 0xac, 0xd7, 0x60, 0xd4, 0x8b,
	0xca, 0x6c, 0x65, 0x85, 0x49, 0xc9, 0x62, 0xac, 0x71, 0x18, 0x2c, 0xa8, 0x0d, 0x7d, 0x88, 0x7a,
	0x75, 0x62, 0xa7, 0xf8, 0x09, 0xc1, 0xc5, 0xb6, 0xf2, 0xba, 0xb9, 0xbb, 0x81, 0x7e, 0xf0, 0x44,
	0x9f, 0x5e, 0xcf, 0xdd, 0xe9, 0xb4, 0x93, 0x3b, 0x35, 0x47, 0xcf, 0xe9, 0xde, 0x0e, 0xe5, 0x05,
	0x9a, 0x2f, 0xb0, 0xff, 0xe2, 0x03, 0x5f, 0xa3, 0x79, 0xb4, 0xca, 0x9c, 0xea, 0x2b, 0x3d, 0xff,
	0xf9, 0x2c, 0xa4, 0x14, 0x36, 0xfe, 0x88, 0x60, 0x28, 0x96, 0xc4, 0xe9, 0x4e, 0x64, 0x6d, 0x1d,
	0xde, 0x98, 0xef, 0x27, 0x25, 0x44, 0xb1, 0xec, 0x37, 0x3f, 0xff, 0xbe, 0x4b, 0xce, 0xe2, 0x69,
	0x22, 0x8a, 0x1e, 0x7f, 0xd1, 0xfe, 0x3f, 0x46, 0x4d, 0x8c, 0x54, 0xb9, 0x53, 0xc3, 0xef, 0x11,
	0x40, 0xdd, 0x36, 0x70, 0x1f, 0x92, 0xd1, 0x81, 0x1b, 0x99, 0xbe, 0x72, 0x34, 0xe7, 0x75, 0xc5,
	0x79, 0x15, 0x4f, 0x75, 0xe5, 0xc4, 0x3f, 0x10, 0x8c, 0x1e, 0x72, 0x36, 0xbc, 0xd4, 0x87, 0x6a,
	0xb3, 0x1b, 0x1b, 0xb7, 0x8f, 0x93, 0xaa, 0xb9, 0x17, 0x15, 0x77, 0x1a, 0x93, 0xee, 0xf3, 0x55,
	0x26, 0x4f, 0xaa, 0xea, 0xa3, 0x86, 0x3f, 0x20, 0x48, 0xa9, 0x5f, 0x25, 0x9e, 0xeb, 0x2a, 0xdf,
	0x68, 0x87, 0x86, 0xdd, 0x6b, 0xb8, 0x26, 0x5c, 0x52, 0x84, 0x19, 0x9c, 0xee, 0x44, 0xa8, 0x2c,
	0x81, 0x54, 0x9b, 0x7c, 0xb6, 0x86, 0xbf, 0x21, 0x18, 0x69, 0x76, 0x1f, 0xbc, 0xd0, 0x9b, 0x7a,
	0xab, 0x5b, 0x1a, 0x8b, 0x7d, 0xe7, 0x69, 0xfc, 0x8c, 0xc2, 0x9f, 0xc3, 0x37, 0xbb, 0xe2, 0x4b,
	0x52, 0x0d, 0x2d, 0x38, 0x04, 0x6f, 0xb6, 0x89, 0x1e, 0xc0, 0xdb, 0xda, 0x57, 0x0f, 0xe0, 0xed,
	0xfd, 0xa8, 0x37, 0xf0, 0xf0, 0x66, 0xd0, 0xa8, 0x42, 0x76, 0x75, 0x77, 0xdf, 0x44, 0x7b, 0xfb,
	0x26, 0xfa, 0xb3, 0x6f, 0xa2, 0xb7, 0x07, 0x66, 0x62, 0xef, 0xc0, 0x4c, 0xfc, 0x3a, 0x30, 0x13,
	0xcf, 0x6e, 0xb9, 0xdc, 0xdf, 0x2c, 0xe7, 0xed, 0x0d, 0x51, 0x24, 0xf1, 0xeb, 0x62, 0x54, 0x79,
	0xb3, 0x9c, 0x27, 0x3b, 0x0b, 0xa4, 0x51, 0xc1, 0xaf, 0x94, 0x98, 0xcc, 0x0f, 0xaa, 0x97, 0xc6,
	0xcc, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x99, 0xc1, 0xf0, 0x27, 0x06, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// MediaNode returns media node details based on id
	MediaNode(ctx context.Context, in *QueryMediaNodeRequest, opts ...grpc.CallOption) (*QueryMediaNodeResponse, error)
	// MediaNodes returns all media nodes with optional pagination
	MediaNodes(ctx context.Context, in *QueryMediaNodesRequest, opts ...grpc.CallOption) (*QueryMediaNodesResponse, error)
	// MediaNodesByOwner returns all media nodes owned by an address
	MediaNodesByOwner(ctx context.Context, in *QueryMediaNodesByOwnerRequest, opts ...grpc.CallOption) (*QueryMediaNodesByOwnerResponse, error)
	// Lease returns lease details for a media node
	Lease(ctx context.Context, in *QueryLeaseRequest, opts ...grpc.CallOption) (*QueryLeaseResponse, error)
	// LeasesByLessee returns all active leases for a lessee address
	LeasesByLessee(ctx context.Context, in *QueryLeasesByLesseeRequest, opts ...grpc.CallOption) (*QueryLeasesByLesseeResponse, error)
	// AvailableNodes returns all unlocked media nodes
	AvailableNodes(ctx context.Context, in *QueryAvailableNodesRequest, opts ...grpc.CallOption) (*QueryAvailableNodesResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) MediaNode(ctx context.Context, in *QueryMediaNodeRequest, opts ...grpc.CallOption) (*QueryMediaNodeResponse, error) {
	out := new(QueryMediaNodeResponse)
	err := c.cc.Invoke(ctx, "/OmniFlix.medianode.v1beta1.Query/MediaNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) MediaNodes(ctx context.Context, in *QueryMediaNodesRequest, opts ...grpc.CallOption) (*QueryMediaNodesResponse, error) {
	out := new(QueryMediaNodesResponse)
	err := c.cc.Invoke(ctx, "/OmniFlix.medianode.v1beta1.Query/MediaNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) MediaNodesByOwner(ctx context.Context, in *QueryMediaNodesByOwnerRequest, opts ...grpc.CallOption) (*QueryMediaNodesByOwnerResponse, error) {
	out := new(QueryMediaNodesByOwnerResponse)
	err := c.cc.Invoke(ctx, "/OmniFlix.medianode.v1beta1.Query/MediaNodesByOwner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Lease(ctx context.Context, in *QueryLeaseRequest, opts ...grpc.CallOption) (*QueryLeaseResponse, error) {
	out := new(QueryLeaseResponse)
	err := c.cc.Invoke(ctx, "/OmniFlix.medianode.v1beta1.Query/Lease", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) LeasesByLessee(ctx context.Context, in *QueryLeasesByLesseeRequest, opts ...grpc.CallOption) (*QueryLeasesByLesseeResponse, error) {
	out := new(QueryLeasesByLesseeResponse)
	err := c.cc.Invoke(ctx, "/OmniFlix.medianode.v1beta1.Query/LeasesByLessee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AvailableNodes(ctx context.Context, in *QueryAvailableNodesRequest, opts ...grpc.CallOption) (*QueryAvailableNodesResponse, error) {
	out := new(QueryAvailableNodesResponse)
	err := c.cc.Invoke(ctx, "/OmniFlix.medianode.v1beta1.Query/AvailableNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// MediaNode returns media node details based on id
	MediaNode(context.Context, *QueryMediaNodeRequest) (*QueryMediaNodeResponse, error)
	// MediaNodes returns all media nodes with optional pagination
	MediaNodes(context.Context, *QueryMediaNodesRequest) (*QueryMediaNodesResponse, error)
	// MediaNodesByOwner returns all media nodes owned by an address
	MediaNodesByOwner(context.Context, *QueryMediaNodesByOwnerRequest) (*QueryMediaNodesByOwnerResponse, error)
	// Lease returns lease details for a media node
	Lease(context.Context, *QueryLeaseRequest) (*QueryLeaseResponse, error)
	// LeasesByLessee returns all active leases for a lessee address
	LeasesByLessee(context.Context, *QueryLeasesByLesseeRequest) (*QueryLeasesByLesseeResponse, error)
	// AvailableNodes returns all unlocked media nodes
	AvailableNodes(context.Context, *QueryAvailableNodesRequest) (*QueryAvailableNodesResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) MediaNode(ctx context.Context, req *QueryMediaNodeRequest) (*QueryMediaNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaNode not implemented")
}
func (*UnimplementedQueryServer) MediaNodes(ctx context.Context, req *QueryMediaNodesRequest) (*QueryMediaNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaNodes not implemented")
}
func (*UnimplementedQueryServer) MediaNodesByOwner(ctx context.Context, req *QueryMediaNodesByOwnerRequest) (*QueryMediaNodesByOwnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaNodesByOwner not implemented")
}
func (*UnimplementedQueryServer) Lease(ctx context.Context, req *QueryLeaseRequest) (*QueryLeaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lease not implemented")
}
func (*UnimplementedQueryServer) LeasesByLessee(ctx context.Context, req *QueryLeasesByLesseeRequest) (*QueryLeasesByLesseeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeasesByLessee not implemented")
}
func (*UnimplementedQueryServer) AvailableNodes(ctx context.Context, req *QueryAvailableNodesRequest) (*QueryAvailableNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AvailableNodes not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_MediaNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMediaNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).MediaNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OmniFlix.medianode.v1beta1.Query/MediaNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).MediaNode(ctx, req.(*QueryMediaNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_MediaNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMediaNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).MediaNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OmniFlix.medianode.v1beta1.Query/MediaNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).MediaNodes(ctx, req.(*QueryMediaNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_MediaNodesByOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMediaNodesByOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).MediaNodesByOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OmniFlix.medianode.v1beta1.Query/MediaNodesByOwner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).MediaNodesByOwner(ctx, req.(*QueryMediaNodesByOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Lease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLeaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Lease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OmniFlix.medianode.v1beta1.Query/Lease",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Lease(ctx, req.(*QueryLeaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_LeasesByLessee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLeasesByLesseeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).LeasesByLessee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OmniFlix.medianode.v1beta1.Query/LeasesByLessee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).LeasesByLessee(ctx, req.(*QueryLeasesByLesseeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AvailableNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAvailableNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AvailableNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OmniFlix.medianode.v1beta1.Query/AvailableNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AvailableNodes(ctx, req.(*QueryAvailableNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "OmniFlix.medianode.v1beta1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MediaNode",
			Handler:    _Query_MediaNode_Handler,
		},
		{
			MethodName: "MediaNodes",
			Handler:    _Query_MediaNodes_Handler,
		},
		{
			MethodName: "MediaNodesByOwner",
			Handler:    _Query_MediaNodesByOwner_Handler,
		},
		{
			MethodName: "Lease",
			Handler:    _Query_Lease_Handler,
		},
		{
			MethodName: "LeasesByLessee",
			Handler:    _Query_LeasesByLessee_Handler,
		},
		{
			MethodName: "AvailableNodes",
			Handler:    _Query_AvailableNodes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "OmniFlix/medianode/v1beta1/query.proto",
}

func (m *QueryMediaNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMediaNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMediaNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryMediaNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMediaNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMediaNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MediaNode.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryMediaNodesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMediaNodesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMediaNodesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryMediaNodesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMediaNodesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMediaNodesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MediaNodes) > 0 {
		for iNdEx := len(m.MediaNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MediaNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryMediaNodesByOwnerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMediaNodesByOwnerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMediaNodesByOwnerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryMediaNodesByOwnerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMediaNodesByOwnerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMediaNodesByOwnerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MediaNodes) > 0 {
		for iNdEx := len(m.MediaNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MediaNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryLeaseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLeaseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLeaseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MediaNodeId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MediaNodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryLeaseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLeaseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLeaseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryLeasesByLesseeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLeasesByLesseeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLeasesByLesseeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Lessee) > 0 {
		i -= len(m.Lessee)
		copy(dAtA[i:], m.Lessee)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Lessee)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryLeasesByLesseeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLeasesByLesseeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLeasesByLesseeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Leases) > 0 {
		for iNdEx := len(m.Leases) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Leases[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryAvailableNodesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAvailableNodesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAvailableNodesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAvailableNodesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAvailableNodesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAvailableNodesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MediaNodes) > 0 {
		for iNdEx := len(m.MediaNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MediaNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryMediaNodeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovQuery(uint64(m.Id))
	}
	return n
}

func (m *QueryMediaNodeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MediaNode.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryMediaNodesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryMediaNodesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MediaNodes) > 0 {
		for _, e := range m.MediaNodes {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryMediaNodesByOwnerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryMediaNodesByOwnerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MediaNodes) > 0 {
		for _, e := range m.MediaNodes {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryLeaseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MediaNodeId != 0 {
		n += 1 + sovQuery(uint64(m.MediaNodeId))
	}
	return n
}

func (m *QueryLeaseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Lease.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryLeasesByLesseeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Lessee)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryLeasesByLesseeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Leases) > 0 {
		for _, e := range m.Leases {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAvailableNodesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAvailableNodesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MediaNodes) > 0 {
		for _, e := range m.MediaNodes {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryMediaNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMediaNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMediaNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMediaNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMediaNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMediaNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MediaNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMediaNodesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMediaNodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMediaNodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMediaNodesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMediaNodesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMediaNodesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaNodes = append(m.MediaNodes, MediaNode{})
			if err := m.MediaNodes[len(m.MediaNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMediaNodesByOwnerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMediaNodesByOwnerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMediaNodesByOwnerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMediaNodesByOwnerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMediaNodesByOwnerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMediaNodesByOwnerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaNodes = append(m.MediaNodes, MediaNode{})
			if err := m.MediaNodes[len(m.MediaNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLeaseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLeaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLeaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaNodeId", wireType)
			}
			m.MediaNodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaNodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLeaseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLeaseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLeaseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLeasesByLesseeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLeasesByLesseeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLeasesByLesseeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lessee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lessee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLeasesByLesseeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLeasesByLesseeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLeasesByLesseeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leases = append(m.Leases, Lease{})
			if err := m.Leases[len(m.Leases)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAvailableNodesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAvailableNodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAvailableNodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAvailableNodesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAvailableNodesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAvailableNodesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaNodes = append(m.MediaNodes, MediaNode{})
			if err := m.MediaNodes[len(m.MediaNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
